[[{"l":"ucumate","p":["ucumate is a developer-friendly Java library for parsing, validating, canonicalizing, and converting units of measure based on the Unified Code for Units of Measure (UCUM) standard. It provides validation, canonicalization, and conversion support with high decimal precision if desired. Furthermore, all special units are supported.","This library requires Java 21 to run. Currently, all dependencies are hosted on the maven central snapshot repository, you need to add it to your pom.xml","You will need the core implementation.","If you used Ucum-java previously you can use the drop-in replacement module.","If you need high precision (especially when special units are involved) then you should use the ucumate-core-exact-special-math module.","If you need data persistence across restarts you can use the ucumate-persistence module.","If you work with mol and mass units a lot you can use the optional ucumate-mol module."]}],[{"l":"Getting Started"},{"l":"Add dependency"},{"l":"Core Functionality","p":["Use the UCUMService class to access the core functionality. This includes printing, validation, canonicalization and conversion.","Read more about the parameter and return types of the UCUMService class in the core functionality documentation."]}],[{"l":"Core Functionality","p":["The ucumate library has three core features:","Printing of UCUM expressions","Validation of UCUM expressions","Canonicalization of UCUM expressions","Conversion UCUM expressions","All functionality can be accessed through a single class: UCUMService. The library heavily uses sealed interface together with switch pattern matching.","By default, the core library caches validation and canonicalization results. Therefore, any subsequent calls to the same expressions lead to blazingly fast results. So the longer the app runs, the faster the answers on average get. You can change these cache settings if desired. You can also add persistent storage if needed."]},{"l":"Printing","p":["Printing more detailed information about a given UCUM expression is very important. Currently, there are 4 print modes:","UCUM Syntax: The parsed UCUM expression is printed in valid UCUM syntax.","Expressive UCUM Syntax: Includes the human-readable name when printing a unit. May be used to understand how an expression has been parsed.","Common Math Syntax: Prints in UCUM Syntax but replaces the math operators with more commonly used ones (i.e. . -> *, + -> ^).","LaTeX Syntax: Produces a string that most LaTeX parsers should be able to process and render.","For example, cm/(s.g2) prints the following:","UCUM Syntax: cm/(s.g+2)","Expressive UCUM Syntax: c (centi)m (meter)/(s (second).g (gram)+2)","Common Math Syntax: cm/(s*g^2)","LaTeX Syntax: \\frac{\\mathrm{cm}}{\\left(\\mathrm{s} \\cdot \\mathrm{g}^{2}\\right)} which renders to rendered_latex","The default printing mode is the UCUM syntax. It is accessible through the UCUMService#print method.","You may also specify the print mode with another parameter."]},{"l":"Validation","p":["UCUMService#validate(String input) can be used to validate any given UCUM expression. The result is either a Success containing the parsed Term or a Failure.","If you are only interested whether a given UCUM expression is valid or invalid you may also use UCUMService#validateToBool(String input)."]},{"l":"Canonicalization","p":["UCUMService#canonicalize can be used to validate any given UCUM expression. The result is either a Success containing the parsed Term and its canonicalization factor obtained during the canonicalization or a FailedCanonicalization."]},{"l":"Conversion","p":["UCUMService#convert can be used to convert any given UCUM expression to another. The result is either a Success containing the resulting conversion facor or a FailedConversion."]}],[{"l":"Cache","p":["By default, the core library has a built-in cache that is enabled. Any expression that is encountered during validation or canonicalization is being cached. If the cache is full then older entries will be removed.","You can configure the cache through three ways:"]},{"l":"Property File","p":["Create a ucumate.properties file in src/main/resources, i.e."]},{"l":"Properties in Java Code","p":["Create a Properties object and call initCache."]},{"l":"Builder Class","p":["<empty list>","10000","A List of Common Codes to be used for Preheating","Below are the properties to control the cache behaviour.","Default Value","Description","Enables/Disables Cache","Enables/Disables Caffeine Stats Tracking","Enables/Disables Overriding default Common Codes List with A Custom Codes List","Enables/Disables Preheating the Cache with Common Codes","false","If you want save the cache between restarts you can add the ucumate-persistence module that ships with a sqlite database by default. When the app starts everything from the data storage will be loaded into the cache.","Max size for Canonical Cache","Max size for Validation Cache","Property Name","There is a fluent builder class to construct cache settings.","true","ucumate.cache.enable","ucumate.cache.maxCanonSize","ucumate.cache.maxValSize","ucumate.cache.preheat","ucumate.cache.preheat.codes","ucumate.cache.preheat.override","ucumate.cache.recordStats"]}],[{"l":"Data Persistence","p":["The core library ships with a default caffeine cache for validation and canonicalization results ( except for mol units. On top of that it is also possible to add another persistent data storage. If a persistent data storage is set up, then on startup all saved codes will be read into the cache (if the cache is enabled).","Add the additional dependency:","The module defines 4 persistence providers out of the box:","SQLite Provider","PostgreSQL Provider","MySQL Provider","MongoDB Provider","By default, the SQLite provider is enabled out of the box as soon as the ucumate-persistence dependency is added. If you want to use a different database option you can override the sqlite one with PersistenceRegistry#register.","The library will write any encountered code into the provided storage. On read, it first looks through the cache (if enabled) and only if it can't find it in the cache, it will query the data storage for it. If it's not in there yet, then it will be calculated once and stored both in cache (if enabled) and in the data storage.","You can also add your own persistence provider by implementing PersistenceProvider and registering it using PersistenceRegistry#register."]}],[{"l":"UCUM Tests","p":["Having a full testsuite to define accordance with the UCUM standard is important. The testsuite should cover a range of valid and invalid expressions and cover canonicalization and conversion including the resulting factors. Grahame Grieve maintains a functional XML testsuite that covers a lot of test cases.","ucumate passes almost all (see section below) the validation and conversion tests defined by Grahame, the other test cases were not tested.","As part of developing the ucumate library, a new test suite has been developed. It is an accumulation of common UCUM codes together with extensive an extensive range of UCUM codes to cover edge cases.","Common UCUM codes in FHIR","Common UCUM units from UCUM","Custom tests","They were transformed into a single json file.","Note: The new testsuite is not meant to replace the XML testsuite (for now). The tests from the older testsuite are not all present in the JSON testsuite.","The core library fails some conversion tests due to limited precision when working with special units. The ucumate-core-exact-special-math implementation passes all tests, so use that if you require high precision.","JSON Testsuite"]},{"l":"Conformance to the UCUMFunctionTestsXML","p":["All tests pass with these exceptions listed below. They are manually marked to be skipped during a test run.","Most of these problems arise from the precision and rounding decisions made in both implementations. Read more about the encountered problems and decisions made regarding conversion factor precision here.","1-108: 10+3/ul is expected to be invalid but ucumate says it's valid. In ucumate any positive integer unit may have an exponent.","3-115: 6.3* s/4/m= 1.6* s/m. ucumate is more precise and does not round in this case. It returns 1.575.","3-121: 1 * 10*-7.s= 1e-7* s. Just a string mismatch, ucumate returns 0.0000001 instead of 1e-7","3-122: 1 * 4.[pi].10*-7.s= 0.00000125663706143591729538506* s. ucumate is more precise by default and returns 0.00000125663706143591729538505735331180115367886776. The last digit ( 6) is rounded and causes the problem. You can configure the desired precision through the PreciseDecimal class.","3-123: Same problem as 3-122.","3-124: 1 * [mu_0]= 0.00125663706143591729538506* g.m.C-2. ucumate is more precise by default returns 0.00125663706143591729538505735331180115367886775975.","3-128: 1 * 1/[ly]= 1.05700083402461546370946e-18 cm-1. ucumate is more precise and does not output conversion factors in scientific notation. It returns 0.00000000000000000105700083402461546370946052448513."]}],[{"l":"Details on the Rounding Behaviour with Numbers provided by the ucum-essence File"},{"l":"Problem","p":["Conversion factors are usually exact numbers (even decimals) that have infinite precision. I.e. the conversion factor from inches to cm is 2.54. It is a decimal number and in a different context it has a limited precision of 3. However, in the context of unit conversion it has unlimited precision. The conversion factor is exactly that, no uncertainty. There are a few exceptions to this. Some units rely on constants that are inherently limited when used in computers. Most notably this includes any unit that relies on pi. To add to this mess, lately (~ 5 years) some constants like the planck constant have been switched from being an inexact measurement to being defined as an exact number. They now have infinite precision. UCUM does not provide a way to differentiate between them and therefore manually sorting and checking has to be done once.","Another problem is when the user provides an additional factor during unit conversion. For example, a user might want to know how much 3.5 inches are in cm. Again, it's not possible for the system to directly know what the precision is. Interpreting the 3.5 as a measurement would indicate that the resulting conversion factor (8.89 cm) should be rounded to 9.0 cm. If the input had been 3.50 then it results in 8.89 cm. Personally, I think its annoying for the user to rely on this behaviour. Instead, a flag could be used where the user marks their input factor as exact with unlimited precision.","There is also the division problem. If two numbers with infinite precision are divided, the resulting number should have infinite precision as well. But the division is often not exact and the result has to be cut to some precision. I.e. the absolute max precision may be 100. The question is how this should be marked. Should the result now have limited precision (100) or should it still be marked as infinite precision and just show the 100 digits.","Additionally, special units also use other more complex math functions. It is not feasible to implement them all with scientific rounding. Therefore, another math lib (big-math) has to be used. In cases where really precise rounding together with special units is needed, this lib would have to be used."]},{"l":"Definitions","p":["Significant digits:","Digits that convey important information regarding the number they are part of. There are three exceptions where a digit may be present but not considered significant:","Leading zeros. I.e. 0.056m has two insignificant digits (the two 0's at the beginning) because the expression may be scaled with a prefix which results in 56mm. Note that this is only the case when the digit before the decimal point is 0.","Trailing zeros (but not in UCUM). In physical measurements they may indicate that a measurement is approximated. In the context of UCUM this is never the case. Here trailing zeros are always understood as intentional and are considered significant.","Spurious digits. If through some way or another the resulting number has more significant figures than any input number, then these additional digits have \"false precision\" and should be discarded.","Identify significant figures","Precision:","The number of significant digits (ignoring leading zeros).","Scale:","The number of digits after the decimal point (ignoring leading zeros).","Integer Number:","Integer numbers are considered to have unlimited precision.","Conversion Factor:","In UCUM there are lots of conversion factors defined that are not integer numbers. For example, the conversion factor from inches to cm is defined as 2.54. This is a decimal number and following the definitions above, it should have a precision of 3 and a scale of 2. However, in the context of unit conversion, there is no ambiguity. The conversion factor between these two units is exactly 2.54, there is no uncertainty. There is an exception to this when the conversion factor involves a unit that is inherently irrational like pi or the gravitational constant."]},{"l":"Scientific Notation","p":["The ucum-essence file uses the scientific notation for many of the conversion factor definitions. For example, the inch to cm conversion factor (2.54) is actually defined as 254e-2. This non-normalized form of the scientific notation can be problematic. 254 is an integer but the normalized or interpreted form is a decimal number with limited precision. In the conversion factor definitions this is not a problem because they are considered to be exact anyway (with a few exceptions)."]},{"l":"User-provided Factor","p":["When canonicalizing or converting between units, the user may provide an additional factor that is used during the calculations. For example, the user might want to convert 3.5 inches to cm. The system is incapable of determining whether this custom factor has limited precision/scaling or not. It depends on what the user wants and therefore (maybe) I can add an additional bool parameter to flag this behaviour?","There is additional complexity when the factor is in scientific notation, especially regarding the decimal places after the dot. 1.0e2 expands to 100.0, 1.00e2 -> 100.00, etc. Conversely, 1.0e-2 expands to 0.010, 1.00e-2 -> 0.0100"]},{"l":"Examples","p":["0 -> unlimited","3 -> unlimited","2.54 (ucum cf) -> unlimited","254e-2 (ucum cf) -> unlimited","1.0 -> p: 2, s: 1","1.00 -> p: 3, s: 2","0.01 -> p: 1, s: 1","0.0100 -> p: 3, s: 3","3.1415926535897932384626433832795028841971693993751058209749445923 (ucum def) -> p: ..., s: p-1"]}],[{"l":"Exact Math","p":["If you work with special units and need high precision during canonicalization or conversion then you should use this additional module.","It is meant as a drop-in replacement for the default math precision in ucumate-core. On startup, you have set the provider once.","Under the hood it uses big-math to perform the complex math operations that are necessary when working with special units. It is much slower than the native but imprecise one. This implementation does not suffer from the floating point precision error that may occur in some canonicalizations or conversions."]}],[{"l":"Feature Flags","p":["The UCUM specification has some ambiguity, and therefore it is not easy to agree on what might be valid UCUM syntax and what not. ucumate provides some feature flags that let the developer choose by which rules to play by."]},{"l":"Setting Feature Flags","p":["To enable or disable these settings application wide, you can use properties of the provided builder class."]},{"l":"Properties","p":["Create a ucumate.properties file in your resource folder."]},{"l":"Builder"},{"l":"Prefixes on Non-Metric Units","p":["The UCUM specification mentions that prefixes (i.e. centi, mili, ...) may only be used on metric units. For example, meter may be prefixed with centi to form centimeter(UCUM syntax: cm). Forming centifoot(UCUM syntax: c[ft_i]) would be invalid. Sometimes this behaviour is desired and therefore this flag exists.","If prefixes on non-metric units are disabled, then da matches the deka prefix which just by itself is invalid UCUM syntax. If enabled, then da matches deci year."]},{"l":"Annotations on Parenthesis","p":["It is not clear whether (m.s){annot} is valid or not. Some common UCUM code lists include such codes, hence this flag exists."]},{"l":"Mol <-> Mass Conversion","p":["The UCUM specification explicitly states that mol (and any unit defined on it) canonicalizes to avogadro's number (dimensionless). This is sometimes undesirable as in different context it can also canonicalize to a mass (usually gram). This requires an additional parameter, the substance's molar mass coefficient."]}],[{"l":"Mole <-> Mass Conversion","p":["In UCUM the mol unit is defined as dimensionless, more precisely 1 mol = 6.02214076*10^23. Here is their reasoning:","The rationale for removing the mole from the base is that the mole is essentially a count of particles expressed in a unit of very high magnitude (Avogadro's number). There is no fundamental difference between the count of particles and the count other things.","ucumate supports both conversions so depending on the provided context:","1 mol = 6.02214076*10^23","1 mol = X * g where X is a provided substance's molar mass coefficient which changes depending on the solution.","There is a property ucumate.enableMolMassConversion which can be used to allow or disallow the conversion application-wide. It is allowed by default.","Enabling this property just allows the mole - mass conversion in general. It does not automatically convert every encountered mol unit to g. You have to explicitly enable this on a per-conversion basis. On the other hand, disabling the property completely prohibits the conversion, and it's not possible to enable it on a per-conversion basis. See below on how to do that.","Assuming the ucumate.enableMolMassConversion property is enabled, you can convert mol(or any unit that canonicalizes to mol) to a mass unit.","If you don't provide the substance coefficient, then the conversion will fail because ucumate will try to convert to the dimensionless unit.","Conversely, if ucumate.enableMolMassConversion is set to false, then converting mole to gram will always fail"]},{"l":"Substance's Molar Mass Values","p":["If you don't want to provide decimal number for the substance's molar mass coefficient you can add the ucumate-mol-support dependency.","This lets you define the coefficient optionally by a different name, casNr, formular, etc."]},{"l":"Special [pH] unit","p":["The [pH] unit is unique in the sense that it is the only unit defined in UCUM that is a special unit and defined on the mole unit. So if mole <-> mass conversion is enabled, in theory it should be possible to also convert [pH] to a mass unit. But it is unclear what this even means or in which context it would be used. Therefore, ucumate explicitly does not allow the conversion of [pH] to a mass unit."]},{"l":"Caching and Storing Behaviour","p":["Caching or storing any canonicalization/conversion where the mol unit (or any unit defined on mol) is not supported. Caching these calculations would require the provided substance's molar mass coefficient to be stored in the cache key as well which is not implemented at the moment."]}],[{"l":"Ucum-Java Legacy Support","p":["ucumate offers a drop-in replacement module for Ucum-java.","You can construct a UcumateToUcumJavaService which implements most of the functionality from the Ucum-java interface definition.","Below you find a detailed description on the differences to the old Ucum-java implementation."]},{"l":"General Differences","p":["A list of special units because they are not implemented here","A string representation of the parsed input expression","An empty list, everything is implemented and supported","analyse","Divide two expressions","divideBy","In principle the same as ucum-java but there are some key differences in validity.","Method","multiply","Multiply two expressions","Not Implemented","The same as ucum-java but different error messages","The same output as ucum-java but it prints a warning when parenthesis ambiguity is encountered","ucum-java","Ucum-java provides some basic feedback when an action failed. I.e. if the given input is invalid, it will return a string message with details. If the input is valid, it returns null. The ucumate-ucumjava-bridge implementation does not return(the same) string error messages. You should only rely on == null or != null checks but not on the string contents itself.","ucumate-ucumjava-bridge","validate","Validate an input","Validate Canonical Units with potential error message","Validate unit with specific property requirement","validateCanonicalUnits","validateInProperty","validateUCUM"]},{"l":"Functional XML Test Difference","p":["Please see the tests page for the difference between ucum-java and ucumate. The ucumate-ucumjava-bridge does change any validation or conversion logic compared to the core implementation."]},{"l":"Functional JSON Test Difference","p":["-1","-5.2","-5{abc}","/Cel","10-5","10+5","12+5","2+5","32","52","55","66","67","68","69","71","72","73","74","75","76","82","83","84","85","86","Cel-2","Cel/3","Cel/Cel","Cel/m","Cel+2","Cel2","da","da is parsed as the single prefix (correctly marked as invalid). But it can also be parsed as dezi * year(if non-metric units are allowed to have prefixes).","During the development of ucumate, a new additional test suite has been created. This adds more extensive edge case tests, but it also has some slightly different validation rules which will be highlighted below.","Expected","Here are all the test cases from the JSON tests where ucum-java differs from ucumate. The ucumate-ucumjava-bridge does change any validation or conversion logic compared to the core implementation.","Input (Diplay)","Invalid","m.5.Cel2.s.2","m.5.Cel2.s/2","m{ }","m{{}","Negative integers are not allowed in UCUM but ucum-java allows it.","Reason","Special units are not allowed to be part of an expression that also contains a division. I.e. Cel/m is invalid. Now it is unclear how this behaves in regard to expression normalization. I.e. m/m canonicalizes to 1. Should therefore Cel/Cel normalize to 1 and be counted as a valid UCUM expression? Currently, this is not the case in ucumate and it will show Cel/Cel as invalid. Please get in contact if you have an opinion on this.","Special units may not be part of a division.","Special units may not be part of a division. ( See Note below)","Special units may not have an exponent and may not be part of a division.","Special units may not have an exponent.","Test ID","The space character is number 32, but only characters inside the range 33-126 may be used.","The UCUM spec states 'Curly brackets may not be nested' but includes { and } as valid symbols inside an annotation. This is ambiguous and there is no use case for this, so ucumate just disallows this. Also see this discussion.","Ucum-java (Actual)","Ucum-java does not allow integer units to be raised to an exponent. This is ambiguous in the UCUM spec but there is no real disadvantage to supporting it, so ucumate allows it.","Valid"]}]]